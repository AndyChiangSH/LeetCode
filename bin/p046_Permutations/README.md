# p046_Permutations

###### tags: `LeetCode` `Medium`

## 題目
[原題目連結](https://leetcode.com/problems/permutations/)

給你一個整數的陣列(數字不重複)，請你列出所有可能的排列組合。

### example 1
```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### example 2
```
Input: nums = [0,1]
Output: [[0,1],[1,0]]
```

## 解題
一看到排列組合的問題，就知道肯定是要用遞迴了。但是因為選過的數字不能再被選，所以需要做點小處理。

### mark array
> Solution1~3
用一個**布林值陣列 mark**，已經走過的數字我們用記為**true**，每遞迴一層就將所有的數字掃過一遍，如果是**false**才選擇再往下一層遞迴。

遞迴一共有 N! 個有效節點，每個節點都是掃過N個數字，所以總複雜度就是**O(N\*N!)**。

### swap
> Solution4

在Discuss上看到的有趣解法，簡單講一下我的理解：
1. 每次將 `first` 和 `[first, end]` 的數字對調，如此一來，**所有尚未挑過的數字都會輪流擔任first的位置**。
2. 再來因為**每向下遞迴一層，first就+1**，`[0, first-1]` 內的數字是不會被改變的，`[first, end]` 內的數字才會被改變。
3. **當first == len時**，所有數字都挑過了，**nums現在的順序就是其中一組解**，將他將入answer的ArrayList中。
4. **在回朔時，別忘了將交換的數字復原!**

聽完之後可能還是一臉矇逼，我看直接看程式的執行流程比較好理解。

```
1 2 3 
  1 2 3 
    1 2 3 
      1 2 3  -> add into answer
    1 3 2 
      1 3 2  -> add into answer
  2 1 3 
    2 1 3 
      2 1 3  -> add into answer
    2 3 1 
      2 3 1  -> add into answer
  3 2 1 
    3 2 1 
      3 2 1  -> add into answer
    3 1 2 
      3 1 2  -> add into answer
```

看的出來答案產生的順序**並沒有照著字典排序**，不過因為這題不看順序所以OK的~

複雜度的部分，因為掃描的長度會隨著遞迴深度漸減，所以複雜度是**O(N!)**。

另外因為這個方法是直接在nums上做in-place的更改，加上少了一個布林陣列，理論上來說，記憶體空間應該要比較小。  


### insert
也是在Discuss上看到的，想法大概是：

1. 先固定其他的數字。
2. 挑一個數字，將他安插在每兩個數字之間。
3. 將安插位置左邊和右邊的區塊對調。
4. 對區塊內重複步驟1~3。

直接看程式流程好了。
```
1 2 3
2 1 3
2 3 1
1 3 2
3 1 2
3 2 1
```

### 後記
理論上來講，swap方法無論在時間或空間上都勝過mark array，但是LeetCode實際跑起來，在時間上一樣快，空間上是mark array比較小...!?  

不過因為LeetCode給個測資都不大，加上伺服器每秒的狀態都不同，同一份程式碼在不同的時間交上去，還會得到不一樣的結果(有時甚至差很多)。所以說嘛...，LeetCode上面的跑分，當成參考就好啦!

## 結果
> mark array  
> 07/09/2021 00:34	Accepted	1 ms	38.7 MB	java  
> 時間：92.42% / 空間：99.33%

> swap  
> 07/09/2021 01:48	Accepted	1 ms	41 MB	java  
> 時間：92.42% / 空間：14.60%