# p338_Counting Bits

###### tags: `LeetCode` `Easy` `DP`

## 題目
[原題目連結](https://leetcode.com/problems/counting-bits/)

給你一個數字n，請求出0~n所有數字的二進位有幾個bits為1。

## 解題

很容易想到的方法是對每一個數字短除法2，算出有幾個餘數為1，這樣做的複雜度是O(n\*log(n))。

進階一點的方法是用動態規劃，利用前面算過的求出後面的答案。仔細觀察一下就會發現這個規律。

```
m = n / 2
r = n % 2
if r == 0: 
    ans[n] = ans[m]
else: 
    ans[n] = ans[m] + 1
```

原因其實很簡單，因為乘以2時就等於將bit左移一位(這應該大家都知道吧?)，也就是說，原本bit為1的數量不會變，會變的就只有LSB。**n是偶數時，LSB為0，所以一樣；n為奇數時，LSB為1，所以會+1。**

### DP解

> **⏳ 時間複雜度：O(n)**  
> **💾 空間複雜度：O(n)**  

## 結果
### DP解

> 03/01/2022 22:03	Accepted	2 ms	47.9 MB	java  
> **⏳ 時間：82.30%**  
> **💾 空間：36.80%**  

## 後記

題目雖然簡單，但沒想到也有應用到動態規劃，真有趣!