# p546_Remove Boxes

###### tags: `LeetCode` `Hard`

## 題目
[原題目連結](https://leetcode.com/problems/remove-boxes/)

這是一個遊戲，給你一個一維陣列，陣列中的數字代表一個箱子，消掉一個箱子可以得到一分，但就像玩Candy Crush一樣，如果旁邊有相同數字的箱子，就可以一起消掉，並得到更高的分數。這邊的規則是如果你同時消掉n的箱子，你可以得到n\*n的分數。

請問，最高的分數是多少?

## 解題

看題目就知道貪婪解肯定是做不到的，因為前面的決定會影響後續的決定，所以感覺應該就是用到動態規劃了。

這題也是三維陣列的動態規劃題目，跟[p913_Cat and Mouse](https://github.com/AndyChiangSH/LeetCode/tree/master/Problem/p913_CatAndMouse)有點像，LeetCode還真多動態規劃的題目。

`dp[i][j][k]`表示子陣列`boxes[i:j]`前面有k個和`boxes[i]`相同的箱子情況下的分數。

有一些情況的分數是已知的：

* `dp[i][j][k] = 0, if j < i`：j如果小於i，這是不成立的情況，所以分數為0。
* `dp[i][j][k] = (k+1)*(k+1), if j = i`：j如果等於i，代表只剩下一個箱子，而前面有k個和`boxes[i]`相同的箱子，因此總共有k+1個箱子，所以分數就是(k+1)\*(k+1)。

我們要的答案是`dp[i][len-1][0] = ?`，我們要用遞迴推出這個值。(k=0非常合理，因為全部的boxes前面不可能會有相同的箱子)

我們對`boxes[i]`有兩種選擇，第一種是將它消除，第二種是將它保留下來，讓他與後面相同的箱子合併，因此推得以下規律：

1. 將`boxes[i]`消除，我們可以先獲得(k+1)\*(k+1)的分數，再加上後面部分的分數`dp[i+1][j][0]`。
2. 將`boxes[i]`保留下來，因此得到的分數是`dp[i+1][m-1][0] + dp[m][j][k+1]`，其中`i < m <= j`，且`boxes[i] == boxes[m]`。簡單講就是將i到m的箱子消除的分數+和m合併後消除得到的分數。

最後，所有可能取最大就是`dp[i][j][k]`的分數。

到這邊就很明顯為什麼要用動態規劃了，因為`dp[i][j][k]`經常被重複呼叫，所以使用動態規劃節省運算時間。

還有另一種方法也是動態規劃，只不過是從底部往回推，時間複雜度會比較大(因為會跑許多沒必要的k)

> **⏳ 時間複雜度：O(n^4^), n=boxes.length, 因為動態規劃總共有n^3^個狀態，每個狀態又用O(n)搜尋m，所以總共為O(n^4^)**  
> **💾 空間複雜度：O(n^3^)**  

## 結果

> 09/03/2021 09:51	Accepted	93 ms	98.9 MB	java  
> **⏳ 時間：55.41%**  
> **💾 空間：33.02%**  

## 後記