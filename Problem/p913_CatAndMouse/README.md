# p913_Cat and Mouse

###### tags: `LeetCode` `Hard`

## 題目
[原題目連結](https://leetcode.com/problems/cat-and-mouse/)

給你一個無向圖，節點0代表老鼠洞，節點1代表老鼠的初始位置，節點2代表貓的初始位置。

遊戲一開始由老鼠先移動，接著輪到貓，每次只能移動一步。如果老鼠進到洞裡，則為老鼠獲勝。如果貓在老鼠進洞前將老鼠抓住(跟老鼠同一格)，則為貓獲勝。如果位置和移動方和上上次的一樣，則算是平手。

老鼠和貓都會選擇最佳的走法，請求出遊戲最後為老鼠獲勝(回傳1)、貓獲勝(回傳2)或平手(回傳0)。

## 解題
### 天真的想法
本來想用貪婪演算法，讓老鼠和貓每次都選最佳的位置，原本是想讓老鼠避開貓並且盡量接近洞，而貓是要讓自己到洞的距離小於老鼠到洞的距離。後來想想這根本不可能，而且遇到一樣近的距離時，就完全是靠運氣在猜了。

就隨便舉個例子看就知道了(小心地滑)：

假設遊戲一開始圖長這樣：
![](https://i.imgur.com/pvJBVqZ.png)

如果貓走這一步，貓就贏了。
![](https://i.imgur.com/WIyf44l.png)

可是如果貓走這一步，貓就輸了。
![](https://i.imgur.com/Iz4doke.png)

兩個點到洞的距離都是1阿，這樣我們怎麼知道該往哪邊走才是最好的?? 總之，這個天真的想法很快就被打臉了。

### Bellman-Ford Relaxation
想了幾天未果，最後只好偷看Discuss，就看到了這個。

他有點是 Bellman-Ford + DP 的概念，用了一個三維陣列表示某情況下的狀態，`state[k][i][j] = value`，k表示輪到貓移動還是老鼠移動，i表示貓的位置，j表示老鼠的位置，而value表示在這個情形(貓在i老鼠在j而輪到k移動)下進行遊戲，最後是老鼠必贏的話為1，貓必贏的話為2，平手為0。

那基本上可以得到以下關係，這個概念很關鍵，如果能接受那離解這題就不遠了。

```
state[cat][i][j] =
    2 if 存在v，使得state[mouse][v][j] == 2
    0 else if 存在v，使得state[mouse][v][j] == 0
    1 else.
    
v 代表i相連的所有節點
```

老鼠的部分也是相同道理，只是全部反轉而已。

概念上其實就像是**象棋的連將**，只要你的下一步是可以連將對手的話，那你這一步勢必也是可以連將的，因為你只要把旗子移動到正確的位置就好啦，而且前提說貓和老鼠都會選擇最佳的走法，因此這是必然成立的關係。

現在問題在於，我們必不知道`state[mouse][v][j]`是多少。但是，我們有一些部份是已知的，也就是遊戲的規則：

* `state[cat][i][0] = 1, i != 0`：老鼠在洞裡，而貓在其他位置，所以老鼠贏了。
* `state[cat/mouse][i][i] = 2, i != 0`：在洞以外的位置，貓和老鼠重疊，所以貓贏了。

接著就是BFS從已知的狀態往回推，最終目的要求出`state[mouse][2][1]`。

但是BFS遇到平手會有問題，會陷入像是有向圖的無限迴圈中，因此解決方法改成使用Bellman-Ford，每次更新整張圖，並將更新的邊紀錄下來，**如果有一輪完成沒有更新的邊，則代表更新結束，`state[mouse][2][1]`的狀態即為答案**。

我參考[這篇Discuss](https://leetcode.com/problems/cat-and-mouse/discuss/1132576/Bellman-Ford-Relaxation%3A-simple-and-clear-code-with-analysis-beats-100-100)，其實應該跟Tim的解法差不多，我看他的寫的滿清楚的，我就不想寫太多了XD

> **⏳ 時間複雜度：O(V^3^ * E)**  
> **💾 空間複雜度：O(V^2^ * 2)**  

## 結果
### Bellman-Ford Relaxation

> 08/27/2021 11:18	Accepted	13 ms	40.3 MB	java  
> **⏳ 時間：94.81%**  
> **💾 空間：36.30%**  

## 後記
將動態規劃拉到三維，是很有意思的一題，滿適合出在資結或演算法的作業上。