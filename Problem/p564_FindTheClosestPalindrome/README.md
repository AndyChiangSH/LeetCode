# p564_Find the Closest Palindrome

###### tags: `LeetCode` `Hard`

## 題目
[原題目連結](https://leetcode.com/problems/find-the-closest-palindrome/)

給你一個字串n，代表一個數字，請求出距離n最近的數字回文為多少(不包括自己)，如果距離相同，則取數字較小的那個。

## 解題
這題沒有什麼特殊的演算法，就只是很多條件判斷很麻煩而已，老實說，我沒有很喜歡像這種的題目。Any way, 既然有人選了，我就要把它寫出來。

我所採用的是對折法，因為回文左右是對稱的，所以只要考慮其中半邊就好，我自己是考慮左半邊，不過字串長度是奇數或偶數，切法也有稍微不同，這點要注意。

接著要取最近的，我把左半邊的部分命名為A，然後取三個數字：
* **upper**：(A+1) + (A+1)'
* **center**：(A) + (A)'
* **lower**：(A-1) + (A-1)'

> `(A)'` 代表A的反轉

當然實際上沒有上面寫得那麼簡單，還要考慮字串長度是奇數或偶數、是否會進位退位...。這部分可以看我程式的條件判斷，我懶得說明了，但這並不是唯一解，我也覺得我沒有寫得很乾淨，當作參考就好。

總之答案就會從這三個中取距離n最近的，例如我以`n=1234`為例：

```
n=1234
A = 12

upper = 1331
center = 1221    // 1221最近
lower = 1111

answer = 1221
```

當然如果n原本就是回文，則center == n，那就是比upper和lower誰比較近，一樣近的話就是lower。

舉`n=1001`為例：

```
n=1001
A = 10

upper = 1111
center = 1001
lower = 999    // 999最近

answer = 999
```

> **⏳ 時間複雜度：O(??)**  
> **💾 空間複雜度：O(3N)**  

順帶一提，String如果要反轉、合併，建議用**StringBuilder**，這是Java內建的字串類別，相較String功能更多而且執行速度更快。

## 結果

> 08/03/2021 10:13	Accepted	2 ms	37.4 MB	java  
> **⏳ 時間：90.41%**  
> **💾 空間：77.86%**  

![](https://i.imgur.com/sF6jOHK.png)

這題其實還有許多地方可以優化，但第一次跑就90%了，我也懶得再優化了~

## 後記
以後看到倒讚比讚多的題目，還是要慎選一下。