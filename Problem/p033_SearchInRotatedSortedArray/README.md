# p033_Search in Rotated Sorted Array

###### tags: `LeetCode` `Medium`

## 題目
[原題目連結](https://leetcode.com/problems/search-in-rotated-sorted-array/)

交換陣列的意思是一個已經排序好的陣列，我們從index=k的位置將陣列分成兩邊，然後左右交換並合併。  
例如：原陣列`[0, 1, 2, 3, 5]`，我們從k=2的位置做交換，交換後得到：`[2, 3, 5, 0, 1]`。

給你一個交換後的陣列`nums[]`和一個整數`target`，請求出`target`在`nums[]`中的索引值，沒有在裡面則回傳-1。

**解題的時間複雜度必須在O(logN)以下。**

## 解題
這題跟演算法HW03_hill finding很像，所以一樣用差不多的方式解題。

### 暴力解
沒有一個for迴圈解決不了的問題! 複雜度是O(N)，顯然是不符合題目的規定。

### 進階二元搜尋
看到複雜度O(logN)就要立刻想到二元搜尋，不過這題因為有交換過，所以跟傳統的二元搜尋不太一樣，簡單講就是...
1. 判斷連續的部分是在左邊還是右邊。
2. 再判斷target有沒有在連續部分的範圍中。
3. 依照以上兩點決定是左邊還是右邊移到中間。
4. 如果中間值等於target，則為找到的情況。
5. 如果最後左邊超過右邊，則為沒找到的情況。

但可能是因為測資不大，其實兩者跑起來沒差多少。

說到這個就順便提一下，我一直很詬病LeetCode規定時間複雜度的方式，既然要限制時間複雜度，那就應該要把測資設計的大一點嘛，不然如果有人用一個for迴圈就解題了，他也不想看Discuss把程式優化的更好，就失去原本這個題目的目的了，感覺是滿可惜的。

## 結果
> 07/04/2021 10:26	Accepted	0 ms	39.4 MB	java  
> 時間：100.00% / 空間：9.86%

空間不知為何都降不下來(?)