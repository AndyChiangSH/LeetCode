# p078_Subsets

###### tags: `LeetCode` `Medium`

## 題目
[原題目連結](https://leetcode.com/problems/subsets/)

給你一個集合(Set)`nums[]`，請求出nums的PowerSet。

## 解題
我覺得這題的解法很難用言語解釋，還是用流程說明好了。

### Recursive (Backtracking)
用遞迴，每層遞迴有for迴圈，只會往後面的去選。

```
以 nums = [1, 2, 3] 為例：

Ø (空集合) // 向後挑1、2、3
1         // 只能向後挑2、3
1 2       // 只能向後挑3
1 2 3     // 沒東西挑
1 3       // 沒東西挑
2         // 只能向後挑3
2 3       // 沒東西挑
3         // 沒東西挑
```

> **⏳ 時間複雜度：O(2^n^)**  
> **💾 空間複雜度：O(2^n^)**  

### Choose or Not
因為每個元素就兩種選擇，要嘛選要嘛不選，所以一條選的遞迴下去，另一條不選的遞迴下去，直到最後一個元素結束。

```
以 nums = [1, 2, 3] 為例：

1 2 3
1 2
1 3
1
2 3
2
3
Ø (空集合)
```

> **⏳ 時間複雜度：O(2^n^)**  
> **💾 空間複雜度：O(2^n^)**  

### Bit Manipulation
就像真質表那樣，1代表選，0代表不選，所有的情況都列出來了。換句話說，總共有2^n^的可能性，第一個元素每1次就反轉(T->F，F->T)，第二個元素每2次就反轉，第三個元素每4次就反轉，其餘依此類推。

求奇偶數 `&1` 比 `%2` 還要快。

```
以 nums = [1, 2, 3] 為例：

            // 對應的真值表
Ø (空集合)   // 0 0 0
1           // 1 0 0
2           // 0 1 0
1 2         // 1 1 0
3           // 0 0 1
1 3         // 1 0 1
2 3         // 0 1 1
1 2 3       // 1 1 1
```

> **⏳ 時間複雜度：O(2^n^)**  
> **💾 空間複雜度：O(2^n^)**  

[這篇Discuss](https://leetcode.com/problems/subsets/discuss/27278/C%2B%2B-RecursiveIterativeBit-Manipulation)整理了三種方法，推薦去看!

## 結果
Bit Manipulation最快，因為是透過位元運算獲得，不需要遞迴。

> 07/30/2021 14:33	Accepted	0 ms	7 MB	cpp  
> **⏳ 時間：100.00%**  
> **💾 空間：83.85%**  

![](https://i.imgur.com/yp5W1XC.png)

## 後記
最近幾題用C\++寫發現一個大問題，就是解題時間大多都卡在C\++本身的問題上，花費了更多時間，我覺得這樣反而本末倒置了QAQ。下周應該就回到用Java吧...